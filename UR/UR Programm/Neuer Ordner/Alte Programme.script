def Alte_Programme():
  set_tcp(p[0.0,-0.051,0.13140000000000002,0.0,3.1415,0.0])
  set_payload(0.4, [0.0, 0.0, 0.1])
  step_count_aaf70b61_3a8c_412a_9c3c_8189c0e26283 = 0.0
  thread Step_Counter_Thread_adabd94f_dd08_43a5_9fef_98bdcfde2154():
    while (True):
      step_count_aaf70b61_3a8c_412a_9c3c_8189c0e26283 = step_count_aaf70b61_3a8c_412a_9c3c_8189c0e26283 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_adabd94f_dd08_43a5_9fef_98bdcfde2154()
  set_safety_mode_transition_hardness(1)
  set_tool_communication(True, 115200, 2, 1, 5.0, 5.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(24)
  set_gravity([0.0, 0.0, 9.82])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  global Aufnahme=p[0.6449502267562484,-0.23285568906876744,0.016270303578516193,5.992152290634535E-16,1.463755010221458E-15,2.358882078654062]
  global Palette_extend=p[0.24614836015339767,-0.6002257611007016,-0.7805000000000001,1.58977340400682E-15,-6.581349388980568E-16,-0.7849999999999997]
  # begin: URCap Installation Node
  #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
  #   Type: Schmalz Gripper
  my_daemon = rpc_factory("xmlrpc", "http://127.0.0.1:39991/RPC2")
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: LIFTKIT, 1.0.5, SKF Actuation System (Liestal) AG
  #   Type: LIFTKIT
  skfliftkit = rpc_factory("xmlrpc", "http://127.0.0.1:40405/RPC2")
  def liftKitReachedPosition(positionEnd, tolerance):
    local positionNow = skfliftkit.get_position()
    local upperLimit = positionEnd + tolerance
    local lowerLimit = positionEnd - tolerance
    if positionNow <= upperLimit:
      if positionNow >= lowerLimit:
        return True
      end
    end
    return False
  end
  def liftKitCheckConnection():
    if (skfliftkit.is_connected() == True):
      return True
    else:
      popup("Not connected to Liftkit. Please go to Installation.", " Not connected! ", False, True, blocking=True)
      halt
      return False
    end
  end
  def liftKitStopMotion():
    skfliftkit.move_stop()
  end
  def liftKitTriggerWdt():
    skfliftkit.trigger_watchdog("move")
  end
  def liftKitIsMoving():
    return skfliftkit.is_moving()
  end
  def get_liftkit_position():
    return skfliftkit.get_position()
  end
  def move_liftkit(liftkitPosition):
    local movingDelay = 0
    local retry = True
    while retry == True:
      retry = False
      if liftKitCheckConnection() == True:
        liftKitStopMotion()
        sleep(0.5)
        liftKitTriggerWdt()
        skfliftkit.move_to_remote_position(liftkitPosition)
        liftKitTriggerWdt()
        while liftKitReachedPosition(liftkitPosition, 1) == False and liftKitCheckConnection() == True and (liftKitIsMoving() == True  or movingDelay < 20):
          if movingDelay < 21:
            movingDelay = movingDelay + 1
          end
          liftKitTriggerWdt()
          sleep(0.1)
        end
        liftKitStopMotion()
        sleep(0.5)
      end
      if liftKitReachedPosition(liftkitPosition, 2) == False:
        popup("Pillar is not in position. Press 'Continue' to retry.", " Position Warning! ", True, False, blocking=True)
        retry = True
        movingDelay = 0
      end
    end
  end
  # end: URCap Installation Node
  global PartPresentSP2= False 
  global Gst_Schmalz_nah_p=p[.446565087499, -.329209107419, .358428484664, .003601506104, .000113398026, .783248883685]
  global Gst_Schmalz_nah_q=[2.168959617614746, -1.4834707540324708, 1.8139274756061, 1.2423412042805175, 1.5721855163574219, 2.955994129180908]
  global Gst_Schm_nah_Mu_p=p[.423322013310, -.346599049692, .170080094527, .047130587699, .019757351055, 2.333985782075]
  global Gst_Schm_nah_Mu_q=[2.052678108215332, -1.2589119237712403, 1.911959473286764, 0.935098333949707, 1.6075196266174316, 1.2886271476745605]
  global Gst_Schmalz_far_p=p[.433209570750, -.393882076105, .367564965177, .011062317880, .015600458455, -2.362060635366]
  global Gst_Schmalz_far_q=[2.1185903549194336, -1.6521359882750453, 1.9646480719195765, -1.8711067638792933, -1.5622108618365687, 2.905947685241699]
  global Gst_Schm_far_Mu_p=p[.501375894358, -.228647258983, .217522025194, -.092795195857, .009157544378, 2.310740654666]
  global Gst_Schm_far_Mu_q=[2.2811241149902344, -1.737429758111471, 2.353556458150045, -2.254904409448141, -1.5467961470233362, 4.678033351898193]
  global Palettenwechsel_p=p[.543469900698, -.388473776786, .315779375136, .004781882604, .014947981736, .872074181786]
  global Palettenwechsel_q=[2.2468180656433105, -1.2712996763041993, 1.6351097265826624, 1.2134622770496826, 1.5856781005859375, 2.945037841796875]
  $ 1 "VorStart"
  $ 2 "Script: Daten_Bereitstellen.script"
  m_data = rpc_factory("xmlrpc", "http://192.168.0.10:10000")
  
  def DatenAuslesen():
    test = m_data.UR_ReadDataFromUsbStick()
    return test
  end
  
  def Dateiname(File):
    m_data.UR_SetFileName(File)
  end
  
  def Palette_Dim():
    palette = m_data.UR_Palette()
    return palette
  end
  
  def Karton():
    karton = m_data.UR_Karton()
    return karton
  end
  
  def Lagen():
    lagen = m_data.UR_Lagen()
    return lagen
  end
  
  def PaketPos(Nummer):
    paket_pos = m_data.UR_PaketPos(Nummer)
    return paket_pos
  end
  
  def AnzLagen():
    anz_lagen = m_data.UR_AnzLagen()
    return anz_lagen
  end
  
  def AnzPakete():
    anz_pakete = m_data.UR_AnzPakete()
    return anz_pakete
  end
  
  def anzPick():
    anz_pick = m_data.UR_PaketeZuordnung()
    return anz_pick
  end
  
  def ZwischenLagen():
    anz_zwlagen = m_data.UR_Zwischenlagen()
    return anz_zwlagen
  end
  
  def gemKartonhoehe():
    gemKart = m_data.UR_Paket_hoehe()
    return gemKart
  end
  
  def aktStartlage():
    startl = m_data.UR_Startlage()
    return startl
  end
  $ 5 "Artikel_Gewicht≔0.435"
  global Artikel_Gewicht=0.435
  $ 6 "Greifer_Gewicht≔1.7"
  global Greifer_Gewicht=1.7
  $ 7 "set_payload_mass(Greifer_Gewicht)"
  set_payload_mass(Greifer_Gewicht)
  $ 8 "Alles_OK≔DatenAuslesen()"
  global Alles_OK=DatenAuslesen()
  $ 9 "Einstellen licht_start=Ein"
  set_standard_digital_out(1, True)
  $ 10 "Einstellen licht_reset=Aus"
  set_standard_digital_out(3, False)
  $ 11 "Einstellen freigabe_convey=Ein"
  set_standard_digital_out(4, True)
  $ 14 "Grundeinstellungen"
  $ 15 "offset_pickup_z≔40"
  global offset_pickup_z=40
  # begin: URCap Program Node
  #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
  #   Type: Schmalz Gripper
  $ 17 "Schmalz: Release"
  set_tool_voltage(24)
  set_tool_digital_out(0, True)
  set_tool_digital_out(1, True)
  sleep(0.5)
  set_tool_digital_out(0, False)
  set_tool_digital_out(1, True)
  sleep(0.05)
  # end: URCap Program Node
  $ 18 "Variablen Nullen"
  $ 19 "liste_paketpos≔[0,0,0,0,0,0,0,0,0]"
  global liste_paketpos=[0,0,0,0,0,0,0,0,0]
  $ 20 "karton_dim≔[0,0,0,0]"
  global karton_dim=[0,0,0,0]
  $ 21 "Paket_Zaehler≔0"
  global Paket_Zaehler=0
  $ 22 "signal≔ False "
  global signal=  False  
  $ 23 "Akt_Lifthoehe≔0"
  global Akt_Lifthoehe=0
  $ 24 "Akt_Lage≔1"
  global Akt_Lage=1
  $ 25 "Akt_Lagenart≔1"
  global Akt_Lagenart=1
  $ 26 "Lagenarten≔Lagen()"
  global Lagenarten=Lagen()
  $ 27 "Zwischenlagen≔ZwischenLagen()"
  global Zwischenlagen=ZwischenLagen()
  $ 28 "Dicke_ZwLagen≔3"
  global Dicke_ZwLagen=3
  $ 29 "Akt_Anz_ZwLagen≔0"
  global Akt_Anz_ZwLagen=0
  $ 30 "Lagenanzahl≔AnzLagen()"
  global Lagenanzahl=AnzLagen()
  $ 31 "Paket_Anzahl≔AnzPakete()"
  global Paket_Anzahl=AnzPakete()
  $ 32 "Pick_Anzahl≔anzPick()"
  global Pick_Anzahl=anzPick()
  $ 33 "Paletten_Masse≔Palette_Dim()"
  global Paletten_Masse=Palette_Dim()
  $ 34 "karton_dim≔Karton()"
  global karton_dim=Karton()
  $ 36 "karton_dim[2]=gemKartonhoehe()"
  karton_dim[2]=gemKartonhoehe()
  $ 37 "kart_hoeh_korre≔0"
  global kart_hoeh_korre=0
  $ 38 "offset_basis≔0"
  global offset_basis=0
  $ 39 "karton_hoehe≔karton_dim[2]-kart_hoeh_korre"
  global karton_hoehe=karton_dim[2]-kart_hoeh_korre
  $ 40 "einlaufrichtung≔karton_dim[3]"
  global einlaufrichtung=karton_dim[3]
  $ 41 "lift_hoehe≔Akt_Lifthoehe"
  global lift_hoehe=Akt_Lifthoehe
  $ 42 "conveyor_start≔ False "
  global conveyor_start=  False  
  $ 43 "Startlage"
  $ 45 "Akt_Lage≔aktStartlage()"
  global Akt_Lage=aktStartlage()
  $ 449 "Thread_1"
  thread Thread_1():
    while (True):
      $ 450 "If einlaufrichtung≟1"
      if (einlaufrichtung == 1):
        $ 451 "If conveyor_start≟ True "
        if (conveyor_start ==   True  ):
          $ 452 "Einstellen freigabe_convey=Ein"
          set_standard_digital_out(4, True)
          $ 453 "Einstellen klemmung=Ein"
          set_standard_digital_out(5, True)
          $ 454 "If paket_vorne≟ False "
          if (get_standard_digital_in(4) ==   False  ):
            $ 455 "Einstellen klemmung=Aus"
            set_standard_digital_out(5, False)
            $ 456 "Warten paket_hinten=HI"
            while (get_standard_digital_in(3) == False):
              sync()
            end
            $ 457 "Einstellen klemmung=Ein"
            set_standard_digital_out(5, True)
            $ 458 "Warten paket_vorne=HI"
            while (get_standard_digital_in(4) == False):
              sync()
            end
          end
        else:
          $ 459 "Else" "noBreak"
          $ 460 "Einstellen freigabe_convey=Aus"
          set_standard_digital_out(4, False)
        end
      end
      $ 461 "sync()"
      sync()
    end
  end
  threadId_Thread_1 = run Thread_1()
  $ 462 "Thread_2"
  thread Thread_2():
    while (True):
      $ 463 "'Signalleuchte Zwischenlage'"
      # 'Signalleuchte Zwischenlage'
      $ 464 "If signal≟ True "
      if (signal ==   True  ):
        $ 465 "Einstellen licht_stopp=Ein"
        set_standard_digital_out(2, True)
        $ 466 "Einstellen licht_start=Ein"
        set_standard_digital_out(1, True)
        $ 467 "Einstellen Akust_Signal=Ein"
        set_standard_digital_out(6, True)
        $ 468 "Warten: 0.5"
        sleep(0.5)
        $ 469 "Einstellen licht_stopp=Aus"
        set_standard_digital_out(2, False)
        $ 470 "Einstellen licht_start=Aus"
        set_standard_digital_out(1, False)
        $ 471 "Einstellen Akust_Signal=Aus"
        set_standard_digital_out(6, False)
        $ 472 "Warten: 0.5"
        sleep(0.5)
      else:
        $ 473 "Else" "noBreak"
        $ 474 "Einstellen licht_stopp=Aus"
        set_standard_digital_out(2, False)
        $ 475 "Einstellen licht_start=Aus"
        set_standard_digital_out(1, False)
        $ 476 "Einstellen Akust_Signal=Aus"
        set_standard_digital_out(6, False)
      end
      $ 477 "sync()"
      sync()
    end
  end
  threadId_Thread_2 = run Thread_2()
  while (True):
    $ 46 "Roboterprogramm"
    $ 56 "Grundstellung"
    $ 57 "FahreAchse"
    $ 59 "Gst_Schmalz_nah" "breakAfter"
    movej(Gst_Schmalz_nah_q, a=1.3962634015954636, v=1.0471975511965976)
    $ 63 "conveyor_start≔ True "
    global conveyor_start=  True  
    $ 65 "Schleife Palette setzen"
    $ 66 "Schleife Akt_Lage<=Lagenanzahl"
    while (Akt_Lage<=Lagenanzahl):
      $ 67 "Akt_Lagenart≔Lagenarten[Akt_Lage-1]"
      global Akt_Lagenart=Lagenarten[Akt_Lage-1]
      $ 68 "Start und Endpaket"
      $ 69 "If Akt_Lagenart>1"
      if (Akt_Lagenart>1):
        $ 70 "zaehl_Lageart≔0"
        global zaehl_Lageart=0
        $ 71 "Endpaket≔0"
        global Endpaket=0
        $ 72 "Schleife zaehl_Lageart<Akt_Lagenart"
        while (zaehl_Lageart<Akt_Lagenart):
          $ 73 "Endpaket≔Endpaket+Pick_Anzahl[zaehl_Lageart]"
          global Endpaket=Endpaket+Pick_Anzahl[zaehl_Lageart]
          $ 74 "zaehl_Lageart≔zaehl_Lageart+1"
          global zaehl_Lageart=zaehl_Lageart+1
        end
        $ 75 "Startpaket≔Endpaket-Pick_Anzahl[Akt_Lagenart-1]"
        global Startpaket=Endpaket-Pick_Anzahl[Akt_Lagenart-1]
      else:
        $ 76 "Else" "noBreak"
        $ 77 "Startpaket≔0"
        global Startpaket=0
        $ 78 "Endpaket≔Pick_Anzahl[Akt_Lagenart-1]"
        global Endpaket=Pick_Anzahl[Akt_Lagenart-1]
      end
      $ 79 "Paket_Zaehler≔Startpaket"
      global Paket_Zaehler=Startpaket
      $ 80 "Akt_pal_hoehe≔(Paletten_Masse[2]/1000)+((karton_hoehe*Akt_Lage)/1000)"
      global Akt_pal_hoehe=(Paletten_Masse[2]/1000)+((karton_hoehe*Akt_Lage)/1000)
      $ 81 "Liftachse fahren"
      $ 82 "max_palett_hoeh≔750"
      global max_palett_hoeh=750
      $ 83 "If Akt_pal_hoehe≥(max_palett_hoeh/1000)"
      if (Akt_pal_hoehe >= (max_palett_hoeh/1000)):
        $ 84 "Lagen_ohne_Lift≔floor((max_palett_hoeh-Paletten_Masse[2])/karton_hoehe)"
        global Lagen_ohne_Lift=floor((max_palett_hoeh-Paletten_Masse[2])/karton_hoehe)
        $ 85 "Akt_Lifthoehe≔(Akt_Lage-Lagen_ohne_Lift)*(karton_hoehe/1000)"
        global Akt_Lifthoehe=(Akt_Lage-Lagen_ohne_Lift)*(karton_hoehe/1000)
        $ 86 "If Akt_Lifthoehe > 0.900"
        if (Akt_Lifthoehe > 0.900):
          $ 87 "Akt_Lifthoehe≔0.900"
          global Akt_Lifthoehe=0.900
        end
        $ 89 "move_liftkit(Akt_Lifthoehe*1000)"
        move_liftkit(Akt_Lifthoehe*1000)
        $ 90 "lift_hoehe≔Akt_Lifthoehe"
        global lift_hoehe=Akt_Lifthoehe
      else:
        $ 91 "Else" "noBreak"
        $ 92 "move_liftkit(0)"
        move_liftkit(0)
      end
      $ 93 "akt_hoe_pick≔karton_hoehe-(lift_hoehe*1000)"
      global akt_hoe_pick=karton_hoehe-(lift_hoehe*1000)
      $ 94 "Aktuelle Palettenhoehe in Bezug zur Basis"
      $ 95 "offset_basis≔(0.87+Akt_Lifthoehe)-Akt_pal_hoehe"
      global offset_basis=(0.87+Akt_Lifthoehe)-Akt_pal_hoehe
      $ 96 "If offset_basis>0"
      if (offset_basis>0):
        $ 97 "sichere_hoehe≔(karton_hoehe/1000)*1.5"
        global sichere_hoehe=(karton_hoehe/1000)*1.5
      end
      $ 98 "If offset_basis≤0"
      if (offset_basis <= 0):
        $ 99 "sichere_hoehe≔(offset_basis*-1)+(karton_hoehe/1000)"
        global sichere_hoehe=(offset_basis*-1)+(karton_hoehe/1000)
      end
      $ 100 "Zwischenlagen zählen"
      $ 101 "counter≔0"
      global counter=0
      $ 102 "Akt_Anz_ZwLagen≔0"
      global Akt_Anz_ZwLagen=0
      $ 103 "Schleife counter<Akt_Lage"
      while (counter<Akt_Lage):
        $ 104 "Akt_Anz_ZwLagen≔Akt_Anz_ZwLagen + Zwischenlagen[counter]"
        global Akt_Anz_ZwLagen=Akt_Anz_ZwLagen + Zwischenlagen[counter]
        $ 105 "counter≔counter+1"
        global counter=counter+1
      end
      $ 106 "akt_hoe_ueber≔(karton_hoehe*(Akt_Lage-1))-(lift_hoehe*1000)"
      global akt_hoe_ueber=(karton_hoehe*(Akt_Lage-1))-(lift_hoehe*1000)
      $ 107 "akt_hoe_place≔(karton_hoehe*Akt_Lage)-(lift_hoehe*1000)+(Akt_Anz_ZwLagen*Dicke_ZwLagen)"
      global akt_hoe_place=(karton_hoehe*Akt_Lage)-(lift_hoehe*1000)+(Akt_Anz_ZwLagen*Dicke_ZwLagen)
      $ 108 "Schleife Lage setzen"
      $ 109 "Schleife Paket_Zaehler<Endpaket"
      while (Paket_Zaehler<Endpaket):
        $ 110 "Paketposition anfragen"
        $ 111 "liste_paketpos≔PaketPos(Paket_Zaehler)"
        global liste_paketpos=PaketPos(Paket_Zaehler)
        $ 112 "If Paket_Zaehler<(Endpaket-1)"
        if (Paket_Zaehler<(Endpaket-1)):
          $ 113 "liste_nxt_paket≔PaketPos(Paket_Zaehler+1)"
          global liste_nxt_paket=PaketPos(Paket_Zaehler+1)
          $ 114 "If liste_nxt_paket[4]≤400"
          if (liste_nxt_paket[4] <= 400):
            $ 115 "Next_Place_near≔ True "
            global Next_Place_near=  True  
          else:
            $ 116 "Else" "noBreak"
            $ 117 "Next_Place_near≔ False "
            global Next_Place_near=  False  
          end
        else:
          $ 118 "Else" "noBreak"
          $ 119 "Next_Place_near≔ True "
          global Next_Place_near=  True  
        end
        $ 120 "If einlaufrichtung≟0"
        if (einlaufrichtung == 0):
          $ 121 "Einlaufrichtung längs"
          $ 122 "pickup_x≔liste_paketpos[0]"
          global pickup_x=liste_paketpos[0]
          $ 123 "pickup_y≔liste_paketpos[1]"
          global pickup_y=liste_paketpos[1]
          $ 124 "pickup_z_vor≔akt_hoe_pick+offset_pickup_z"
          global pickup_z_vor=akt_hoe_pick+offset_pickup_z
          $ 126 "If liste_paketpos[6]≥2"
          if (liste_paketpos[6] >= 2):
            $ 127 "2 Paket Startposition laengs"
            $ 128 "pickup_rot≔d2r(liste_paketpos[2]+90)"
            global pickup_rot= d2r (liste_paketpos[2]+90)
            $ 129 "Vor_Aufn_Pose≔p[pickup_x/1000,pickup_y/1000,pickup_z_vor/1000,0,0,pickup_rot]"
            global Vor_Aufn_Pose=p[pickup_x/1000,pickup_y/1000,pickup_z_vor/1000,0,0,pickup_rot]
            $ 130 "FahreAchse"
            $ 131 "Vor_Aufn_Pose" "breakAfter"
            movej(pose_trans(Aufnahme, Vor_Aufn_Pose), a=2.792526803190927, v=2.0943951023931953)
            $ 132 "vor_aufn_gelenk≔get_actual_joint_positions()"
            global vor_aufn_gelenk= get_actual_joint_positions ()
            $ 133 "2 Paket laengs aufnehmen"
            $ 134 "Aufn_Pos≔p[pickup_x/1000,pickup_y/1000,((akt_hoe_pick-8)/1000),0,0,pickup_rot]"
            global Aufn_Pos=p[pickup_x/1000,pickup_y/1000,((akt_hoe_pick-8)/1000),0,0,pickup_rot]
            $ 135 "Warten paket_vorne=HI"
            while (get_standard_digital_in(4) == False):
              sync()
            end
            $ 136 "Warten paket_hinten=HI"
            while (get_standard_digital_in(3) == False):
              sync()
            end
            $ 137 "Warten: 1.5"
            sleep(1.5)
            $ 138 "Warten paket_hinten=HI"
            while (get_standard_digital_in(3) == False):
              sync()
            end
            $ 140 "FahreLinear"
            $ 141 "Aufn_Pos" "breakAfter"
            movel(pose_trans(Aufnahme, Aufn_Pos), a=0.16, v=0.32)
            # begin: URCap Program Node
            #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
            #   Type: Schmalz Gripper
            $ 143 "Schmalz: Suction"
            set_tool_voltage(24)
            set_tool_digital_out(0, False)
            set_tool_digital_out(1, False)
            wait_threshold_s = 1.5
            current_time_cnt = 0.0
            while (current_time_cnt<wait_threshold_s):
              set_tool_digital_out(0, False)
              set_tool_digital_out(1, False)
              if (get_tool_digital_in(1)):
                break
              end
              current_time_cnt = current_time_cnt+0.1
              sleep(0.1)
            end
            # end: URCap Program Node
            $ 144 "set_payload_mass(Greifer_Gewicht+(Artikel_Gewicht*liste_paketpos[6]))"
            set_payload_mass(Greifer_Gewicht+(Artikel_Gewicht*liste_paketpos[6]))
            $ 145 "Freifahren Aufnahme"
            $ 146 "tmp_pose_1≔get_actual_tcp_pose()"
            global tmp_pose_1= get_actual_tcp_pose ()
            $ 147 "Einstellen freigabe_convey=Aus"
            set_standard_digital_out(4, False)
            $ 148 "tmp_pose_zwi≔pose_trans(tmp_pose_1, p[0,0,0.2,0,0,0])"
            global tmp_pose_zwi=pose_trans(tmp_pose_1, p[0,0,0.2,0,0,0])
            $ 150 "FahreLinear"
            $ 151 "tmp_pose_zwi" "breakAfter"
            movel(tmp_pose_zwi, a=0.18, v=0.32)
            $ 153 "conveyor_start≔ True "
            global conveyor_start=  True  
            $ 154 "Einstellen freigabe_convey=Ein"
            set_standard_digital_out(4, True)
            $ 155 "Zwischenposition"
            $ 156 "If einlaufrichtung≟1"
            if (einlaufrichtung == 1):
              $ 157 "place_rot_ueb≔d2r(liste_paketpos[5]-225)"
              global place_rot_ueb=d2r(liste_paketpos[5]-225)
            else:
              $ 158 "Else" "noBreak"
              $ 159 "place_rot_ueb≔d2r(liste_paketpos[5]+45)"
              global place_rot_ueb=d2r(liste_paketpos[5]+45)
            end
            $ 160 "tmp_pose_1≔get_actual_tcp_pose()"
            global tmp_pose_1= get_actual_tcp_pose ()
            $ 161 "pose_zwischen≔pose_add(tmp_pose_1, p[-0.360,-0.360,0,0,0,0]) "
            global pose_zwischen= pose_add (tmp_pose_1, p[-0.360,-0.360,0,0,0,0]) 
            $ 162 "pose_zwischen[2]=sichere_hoehe"
            pose_zwischen[2]=sichere_hoehe
            $ 163 "pose_ueb_pal_2≔p[-0.605,-0.570,sichere_hoehe,0,0,place_rot_ueb]"
            global pose_ueb_pal_2=p[-0.605,-0.570,sichere_hoehe,0,0,place_rot_ueb]
            $ 166 "FahreAchse"
            $ 167 "pose_zwischen" "breakAfter"
            movej(pose_zwischen, a=3.141592653589793, v=3.141592653589793)
            $ 170 "pose_ueb_pal_2" "breakAfter"
            movej(pose_ueb_pal_2, a=3.141592653589793, v=3.141592653589793)
            $ 171 "gelen_ueb_pal_2≔get_actual_joint_positions()"
            global gelen_ueb_pal_2= get_actual_joint_positions ()
          else:
            $ 172 "Else" "noBreak"
            $ 173 "1 Paket aufnehmen"
            $ 174 "pickup_rot≔d2r(liste_paketpos[2])"
            global pickup_rot= d2r (liste_paketpos[2])
            $ 175 "Vor_Aufn_Pose≔p[pickup_x/1000,pickup_y/1000,pickup_z_vor/1000,0,0,pickup_rot]"
            global Vor_Aufn_Pose=p[pickup_x/1000,pickup_y/1000,pickup_z_vor/1000,0,0,pickup_rot]
            $ 176 "FahreAchse"
            $ 177 "Vor_Aufn_Pose" "breakAfter"
            movej(pose_trans(Aufnahme, Vor_Aufn_Pose), a=2.0943951023931953, v=3.141592653589793)
            $ 178 "vor_aufn_gelenk≔get_actual_joint_positions()"
            global vor_aufn_gelenk= get_actual_joint_positions ()
            $ 179 "1 Paket quer aufnehmen"
            $ 180 "Aufn_Pos≔p[pickup_x/1000,pickup_y/1000,((akt_hoe_pick-8)/1000),0,0,pickup_rot]"
            global Aufn_Pos=p[pickup_x/1000,pickup_y/1000,((akt_hoe_pick-8)/1000),0,0,pickup_rot]
            $ 181 "Warten paket_vorne=HI"
            while (get_standard_digital_in(4) == False):
              sync()
            end
            $ 182 "Warten: 0.1"
            sleep(0.1)
            $ 183 "conveyor_start≔ False "
            global conveyor_start=  False  
            $ 184 "FahreLinear"
            $ 185 "Aufn_Pos" "breakAfter"
            movel(pose_trans(Aufnahme, Aufn_Pos), a=0.1, v=0.2)
            # begin: URCap Program Node
            #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
            #   Type: Schmalz Gripper
            $ 187 "Schmalz: Suction"
            set_tool_voltage(24)
            set_tool_digital_out(0, False)
            set_tool_digital_out(1, False)
            wait_threshold_s = 1.5
            current_time_cnt = 0.0
            while (current_time_cnt<wait_threshold_s):
              set_tool_digital_out(0, False)
              set_tool_digital_out(1, False)
              if (get_tool_digital_in(1)):
                break
              end
              current_time_cnt = current_time_cnt+0.1
              sleep(0.1)
            end
            # end: URCap Program Node
            $ 188 "set_payload_mass(Greifer_Gewicht+Artikel_Gewicht)"
            set_payload_mass(Greifer_Gewicht+Artikel_Gewicht)
            $ 189 "Freifahren Aufnahme"
            $ 190 "tmp_pose_1≔get_actual_tcp_pose()"
            global tmp_pose_1= get_actual_tcp_pose ()
            $ 191 "tmp_pose_zwi≔pose_trans(tmp_pose_1, p[0,0,0.1,0,0,0])"
            global tmp_pose_zwi=pose_trans(tmp_pose_1, p[0,0,0.1,0,0,0])
            $ 193 "FahreLinear"
            $ 194 "tmp_pose_zwi" "breakAfter"
            movel(tmp_pose_zwi, a=0.18, v=0.36)
            $ 196 "conveyor_start≔ True "
            global conveyor_start=  True  
            $ 197 "Zwischenposition"
            $ 198 "If einlaufrichtung≟0"
            if (einlaufrichtung == 0):
              $ 199 "place_rot_ueb≔d2r(liste_paketpos[5]-225)"
              global place_rot_ueb=d2r(liste_paketpos[5]-225)
            else:
              $ 200 "Else" "noBreak"
              $ 201 "place_rot_ueb≔d2r(liste_paketpos[5]-315)"
              global place_rot_ueb=d2r(liste_paketpos[5]-315)
            end
            $ 202 "tmp_pose_1≔get_actual_tcp_pose()"
            global tmp_pose_1= get_actual_tcp_pose ()
            $ 203 "pose_zwischen≔pose_add(tmp_pose_1, p[-0.360,-0.360,sichere_hoehe,0,0,0])"
            global pose_zwischen= pose_add (tmp_pose_1, p[-0.360,-0.360,sichere_hoehe,0,0,0])
            $ 204 "pose_zwischen[2]=sichere_hoehe"
            pose_zwischen[2]=sichere_hoehe
            $ 205 "pose_ueb_pal_2≔p[-0.550,-0.650,sichere_hoehe,0,0,place_rot_ueb]"
            global pose_ueb_pal_2=p[-0.550,-0.650,sichere_hoehe,0,0,place_rot_ueb]
            $ 207 "FahreAchse"
            $ 208 "pose_zwischen" "breakAfter"
            movej(pose_zwischen, a=2.0943951023931953, v=3.141592653589793, r=0.1)
            $ 210 "pose_ueb_pal_2" "breakAfter"
            movej(pose_ueb_pal_2, a=2.0943951023931953, v=3.141592653589793)
            $ 211 "gelen_ueb_pal_2≔get_actual_joint_positions()"
            global gelen_ueb_pal_2= get_actual_joint_positions ()
          end
        else:
          $ 212 "Else" "noBreak"
          $ 213 "Einlaufrichtung quer"
          $ 214 "'X und Y vertauscht'"
          # 'X und Y vertauscht'
          $ 215 "pickup_x≔liste_paketpos[1]*(-1)"
          global pickup_x=liste_paketpos[1]*(-1)
          $ 216 "pickup_y≔liste_paketpos[0]*(-1)"
          global pickup_y=liste_paketpos[0]*(-1)
          $ 217 "pickup_z_vor≔akt_hoe_pick+offset_pickup_z"
          global pickup_z_vor=akt_hoe_pick+offset_pickup_z
          $ 218 "If liste_paketpos[6]≟1"
          if (liste_paketpos[6] == 1):
            $ 219 "1 Paket Startposition"
            $ 220 "pickup_rot≔d2r(liste_paketpos[2]+90)"
            global pickup_rot= d2r (liste_paketpos[2]+90)
            $ 221 "Vor_Aufn_Pose≔p[pickup_x/1000,pickup_y/1000,pickup_z_vor/1000,0,0,pickup_rot]"
            global Vor_Aufn_Pose=p[pickup_x/1000,pickup_y/1000,pickup_z_vor/1000,0,0,pickup_rot]
            $ 222 "FahreAchse"
            $ 223 "Vor_Aufn_Pose" "breakAfter"
            movej(pose_trans(Aufnahme, Vor_Aufn_Pose), a=2.792526803190927, v=3.141592653589793)
            $ 224 "vor_aufn_gelenk≔get_actual_joint_positions()"
            global vor_aufn_gelenk= get_actual_joint_positions ()
            $ 225 "1 Paket aufnehmen"
            $ 226 "Aufn_Pos≔p[pickup_x/1000,pickup_y/1000,((akt_hoe_pick)/1000),0,0,pickup_rot]"
            global Aufn_Pos=p[pickup_x/1000,pickup_y/1000,((akt_hoe_pick)/1000),0,0,pickup_rot]
            $ 227 "Warten paket_vorne=HI"
            while (get_standard_digital_in(4) == False):
              sync()
            end
            $ 228 "Warten: 0.1"
            sleep(0.1)
            $ 230 "FahreLinear"
            $ 231 "Aufn_Pos" "breakAfter"
            movel(pose_trans(Aufnahme, Aufn_Pos), a=0.16, v=0.32)
            # begin: URCap Program Node
            #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
            #   Type: Schmalz Gripper
            $ 233 "Schmalz: Suction"
            set_tool_voltage(24)
            set_tool_digital_out(0, False)
            set_tool_digital_out(1, False)
            wait_threshold_s = 1.5
            current_time_cnt = 0.0
            while (current_time_cnt<wait_threshold_s):
              set_tool_digital_out(0, False)
              set_tool_digital_out(1, False)
              if (get_tool_digital_in(1)):
                break
              end
              current_time_cnt = current_time_cnt+0.1
              sleep(0.1)
            end
            # end: URCap Program Node
            $ 234 "set_payload_mass(Greifer_Gewicht+Artikel_Gewicht)"
            set_payload_mass(Greifer_Gewicht+Artikel_Gewicht)
            $ 235 "Freifahren Aufnahme"
            $ 236 "tmp_pose_1≔get_actual_tcp_pose()"
            global tmp_pose_1= get_actual_tcp_pose ()
            $ 237 "tmp_pose_zwi≔pose_trans(tmp_pose_1, p[0,0,0.08,0,0,0])"
            global tmp_pose_zwi=pose_trans(tmp_pose_1, p[0,0,0.08,0,0,0])
            $ 238 "FahreLinear"
            $ 239 "tmp_pose_zwi" "breakAfter"
            movel(tmp_pose_zwi, a=0.12, v=0.32)
            $ 240 "conveyor_start≔ True "
            global conveyor_start=  True  
            $ 241 "Zwischenposition"
            $ 242 "If einlaufrichtung≟0"
            if (einlaufrichtung == 0):
              $ 243 "place_rot_ueb≔d2r(liste_paketpos[5]-225)"
              global place_rot_ueb=d2r(liste_paketpos[5]-225)
            else:
              $ 244 "Else" "noBreak"
              $ 245 "place_rot_ueb≔d2r(liste_paketpos[5]-45)"
              global place_rot_ueb=d2r(liste_paketpos[5]-45)
            end
            $ 246 "tmp_pose_1≔get_actual_tcp_pose()"
            global tmp_pose_1= get_actual_tcp_pose ()
            $ 247 "pose_zwischen≔pose_add(tmp_pose_1, p[-0.360,-0.360,sichere_hoehe,0,0,0])"
            global pose_zwischen= pose_add (tmp_pose_1, p[-0.360,-0.360,sichere_hoehe,0,0,0])
            $ 248 "pose_zwischen[2]=sichere_hoehe"
            pose_zwischen[2]=sichere_hoehe
            $ 249 "pose_ueb_pal_2≔p[-0.600,-0.650,sichere_hoehe,0,0,place_rot_ueb]"
            global pose_ueb_pal_2=p[-0.600,-0.650,sichere_hoehe,0,0,place_rot_ueb]
            $ 250 "FahreAchse"
            $ 251 "pose_zwischen" "breakAfter"
            movej(pose_zwischen, a=2.0943951023931953, v=2.792526803190927, r=0.1)
            $ 252 "pose_ueb_pal_2" "breakAfter"
            movej(pose_ueb_pal_2, a=2.0943951023931953, v=2.792526803190927)
            $ 253 "gelen_ueb_pal_2≔get_actual_joint_positions()"
            global gelen_ueb_pal_2= get_actual_joint_positions ()
          else:
            $ 254 "ElseIf liste_paketpos[6]≟2"
            if (liste_paketpos[6] == 2):
              $ 255 "2 Pakete aufnehmen"
              $ 256 "pickup_rot≔d2r(liste_paketpos[2])"
              global pickup_rot= d2r (liste_paketpos[2])
              $ 257 "Vor_Aufn_Pose≔p[pickup_x/1000,0,pickup_z_vor/1000,0,0,pickup_rot]"
              global Vor_Aufn_Pose=p[pickup_x/1000,0,pickup_z_vor/1000,0,0,pickup_rot]
              $ 258 "FahreAchse"
              $ 259 "Vor_Aufn_Pose" "breakAfter"
              movej(pose_trans(Aufnahme, Vor_Aufn_Pose), a=1.3962634015954636, v=1.0471975511965976)
              $ 260 "vor_aufn_gelenk≔get_actual_joint_positions()"
              global vor_aufn_gelenk= get_actual_joint_positions ()
              $ 261 "Erstes Paket aufnehmen"
              $ 262 "Aufn_Pos≔p[pickup_x/1000,0,((akt_hoe_pick)/1000),0,0,pickup_rot]"
              global Aufn_Pos=p[pickup_x/1000,0,((akt_hoe_pick)/1000),0,0,pickup_rot]
              $ 263 "Warten paket_vorne=HI"
              while (get_standard_digital_in(4) == False):
                sync()
              end
              $ 264 "Warten: 0.1"
              sleep(0.1)
              $ 266 "FahreLinear"
              $ 267 "Aufn_Pos" "breakAfter"
              movel(pose_trans(Aufnahme, Aufn_Pos), a=0.12, v=0.32)
              # begin: URCap Program Node
              #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
              #   Type: Schmalz Gripper
              $ 269 "Schmalz: Suction"
              set_tool_voltage(24)
              set_tool_digital_out(0, False)
              set_tool_digital_out(1, False)
              wait_threshold_s = 1.5
              current_time_cnt = 0.0
              while (current_time_cnt<wait_threshold_s):
                set_tool_digital_out(0, False)
                set_tool_digital_out(1, False)
                if (get_tool_digital_in(1)):
                  break
                end
                current_time_cnt = current_time_cnt+0.1
                sleep(0.1)
              end
              # end: URCap Program Node
              $ 270 "set_payload_mass(Greifer_Gewicht+Artikel_Gewicht)"
              set_payload_mass(Greifer_Gewicht+Artikel_Gewicht)
              $ 271 "Zweites Paket aufnehmen"
              $ 272 "Vor_Aufn_Pose≔p[pickup_x/1000,((pickup_y/1000)-0.02),pickup_z_vor/1000,0,0,pickup_rot]"
              global Vor_Aufn_Pose=p[pickup_x/1000,((pickup_y/1000)-0.02),pickup_z_vor/1000,0,0,pickup_rot]
              $ 273 "FahreLinear"
              $ 274 "Vor_Aufn_Pose" "breakAfter"
              movel(pose_trans(Aufnahme, Vor_Aufn_Pose), a=0.12, v=0.32)
              $ 276 "Warten paket_vorne=HI"
              while (get_standard_digital_in(4) == False):
                sync()
              end
              $ 279 "Aufn_Pos≔p[pickup_x/1000,pickup_y/1000,((akt_hoe_pick)/1000),0,0,pickup_rot]"
              global Aufn_Pos=p[pickup_x/1000,pickup_y/1000,((akt_hoe_pick)/1000),0,0,pickup_rot]
              $ 280 "Aufn_Pos_vor≔p[pickup_x/1000,pickup_y/1000,pickup_z_vor/1000,0,0,pickup_rot]"
              global Aufn_Pos_vor=p[pickup_x/1000,pickup_y/1000,pickup_z_vor/1000,0,0,pickup_rot]
              $ 281 "FahreLinear"
              $ 282 "Aufn_Pos_vor" "breakAfter"
              movel(pose_trans(Aufnahme, Aufn_Pos_vor), a=0.12, v=0.32)
              $ 283 "Aufn_Pos" "breakAfter"
              movel(pose_trans(Aufnahme, Aufn_Pos), a=0.12, v=0.32)
              # begin: URCap Program Node
              #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
              #   Type: Schmalz Gripper
              $ 285 "Schmalz: Release"
              set_tool_voltage(24)
              set_tool_digital_out(0, True)
              set_tool_digital_out(1, True)
              sleep(0.5)
              set_tool_digital_out(0, False)
              set_tool_digital_out(1, True)
              sleep(0.05)
              # end: URCap Program Node
              $ 286 "Warten: 0.5"
              sleep(0.5)
              # begin: URCap Program Node
              #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
              #   Type: Schmalz Gripper
              $ 288 "Schmalz: Suction"
              set_tool_voltage(24)
              set_tool_digital_out(0, False)
              set_tool_digital_out(1, False)
              wait_threshold_s = 1.5
              current_time_cnt = 0.0
              while (current_time_cnt<wait_threshold_s):
                set_tool_digital_out(0, False)
                set_tool_digital_out(1, False)
                if (get_tool_digital_in(1)):
                  break
                end
                current_time_cnt = current_time_cnt+0.1
                sleep(0.1)
              end
              # end: URCap Program Node
              $ 289 "set_payload_mass(Greifer_Gewicht+(Artikel_Gewicht*2))"
              set_payload_mass(Greifer_Gewicht+(Artikel_Gewicht*2))
              $ 290 "Freifahren"
              $ 291 "tmp_pose_1≔get_actual_tcp_pose()"
              global tmp_pose_1= get_actual_tcp_pose ()
              $ 292 "tmp_pose_zwi≔pose_trans(tmp_pose_1, p[0,0,0.08,0,0,0])"
              global tmp_pose_zwi=pose_trans(tmp_pose_1, p[0,0,0.08,0,0,0])
              $ 293 "FahreLinear"
              $ 294 "tmp_pose_zwi" "breakAfter"
              movel(tmp_pose_zwi, a=0.06, v=0.16)
              $ 295 "conveyor_start≔ True "
              global conveyor_start=  True  
              $ 296 "Zwischenposition"
              $ 297 "place_rot_ueb≔d2r(liste_paketpos[5]+135)"
              global place_rot_ueb=d2r(liste_paketpos[5]+135)
              $ 298 "tmp_pose_1≔get_actual_tcp_pose()"
              global tmp_pose_1= get_actual_tcp_pose ()
              $ 299 "pose_zwischen≔pose_add(tmp_pose_1, p[-0.360,-0.360,0,0,0,0])"
              global pose_zwischen= pose_add (tmp_pose_1, p[-0.360,-0.360,0,0,0,0])
              $ 300 "pose_zwischen[2]=sichere_hoehe"
              pose_zwischen[2]=sichere_hoehe
              $ 301 "pose_ueb_pal_2≔p[-0.600,-0.650,sichere_hoehe,0,0,place_rot_ueb]"
              global pose_ueb_pal_2=p[-0.600,-0.650,sichere_hoehe,0,0,place_rot_ueb]
              $ 302 "FahreAchse"
              $ 303 "pose_zwischen" "breakAfter"
              movej(pose_zwischen, a=1.0471975511965976, v=1.5707963267948966)
              $ 304 "pose_ueb_pal_2" "breakAfter"
              movej(pose_ueb_pal_2, a=1.0471975511965976, v=1.5707963267948966)
              $ 305 "gelen_ueb_pal_2≔get_actual_joint_positions()"
              global gelen_ueb_pal_2= get_actual_joint_positions ()
            else:
              $ 306 "ElseIf liste_paketpos[6]≟3"
              if (liste_paketpos[6] == 3):
                $ 307 "3 Pakete aufnehmen"
                $ 308 "pickup_rot≔d2r(liste_paketpos[2])"
                global pickup_rot= d2r (liste_paketpos[2])
                $ 309 "Vor_Aufn_Pose≔p[pickup_x/1000,karton_dim[1]/2000,pickup_z_vor/1000,0,0,pickup_rot]"
                global Vor_Aufn_Pose=p[pickup_x/1000,karton_dim[1]/2000,pickup_z_vor/1000,0,0,pickup_rot]
                $ 310 "FahreAchse"
                $ 311 "Vor_Aufn_Pose" "breakAfter"
                movej(pose_trans(Aufnahme, Vor_Aufn_Pose), a=1.3962634015954636, v=1.0471975511965976)
                $ 312 "vor_aufn_gelenk≔get_actual_joint_positions()"
                global vor_aufn_gelenk= get_actual_joint_positions ()
                $ 313 "Erstes Paket aufnehmen"
                $ 314 "Aufn_Pos≔p[pickup_x/1000,karton_dim[1]/2000,((akt_hoe_pick)/1000),0,0,pickup_rot]"
                global Aufn_Pos=p[pickup_x/1000,karton_dim[1]/2000,((akt_hoe_pick)/1000),0,0,pickup_rot]
                $ 315 "Warten paket_vorne=HI"
                while (get_standard_digital_in(4) == False):
                  sync()
                end
                $ 316 "Warten: 0.1"
                sleep(0.1)
                $ 317 "FahreLinear"
                $ 318 "Aufn_Pos" "breakAfter"
                movel(pose_trans(Aufnahme, Aufn_Pos), a=0.08, v=0.16)
                # begin: URCap Program Node
                #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
                #   Type: Schmalz Gripper
                $ 320 "Schmalz: Suction"
                set_tool_voltage(24)
                set_tool_digital_out(0, False)
                set_tool_digital_out(1, False)
                wait_threshold_s = 1.5
                current_time_cnt = 0.0
                while (current_time_cnt<wait_threshold_s):
                  set_tool_digital_out(0, False)
                  set_tool_digital_out(1, False)
                  if (get_tool_digital_in(1)):
                    break
                  end
                  current_time_cnt = current_time_cnt+0.1
                  sleep(0.1)
                end
                # end: URCap Program Node
                $ 321 "set_payload_mass(Greifer_Gewicht+Artikel_Gewicht)"
                set_payload_mass(Greifer_Gewicht+Artikel_Gewicht)
                $ 322 "Zweites Paket aufnehmen"
                $ 323 "Vor_Aufn_Pose≔p[pickup_x/1000,(-1*((karton_dim[1]/2000)+0.01)),pickup_z_vor/1000,0,0,pickup_rot]"
                global Vor_Aufn_Pose=p[pickup_x/1000,(-1*((karton_dim[1]/2000)+0.01)),pickup_z_vor/1000,0,0,pickup_rot]
                $ 324 "FahreLinear"
                $ 325 "Vor_Aufn_Pose" "breakAfter"
                movel(pose_trans(Aufnahme, Vor_Aufn_Pose), a=0.08, v=0.16)
                $ 326 "Warten paket_vorne=HI"
                while (get_standard_digital_in(4) == False):
                  sync()
                end
                $ 327 "Aufn_Pos≔p[pickup_x/1000,(-1*(karton_dim[1]/2000)),((akt_hoe_pick)/1000),0,0,pickup_rot]"
                global Aufn_Pos=p[pickup_x/1000,(-1*(karton_dim[1]/2000)),((akt_hoe_pick)/1000),0,0,pickup_rot]
                $ 328 "Vor_Aufn_Pose≔p[pickup_x/1000,(-1*(karton_dim[1]/2000)),pickup_z_vor/1000,0,0,pickup_rot]"
                global Vor_Aufn_Pose=p[pickup_x/1000,(-1*(karton_dim[1]/2000)),pickup_z_vor/1000,0,0,pickup_rot]
                $ 329 "FahreLinear"
                $ 330 "Vor_Aufn_Pose" "breakAfter"
                movel(pose_trans(Aufnahme, Vor_Aufn_Pose), a=0.08, v=0.16)
                $ 331 "Aufn_Pos" "breakAfter"
                movel(pose_trans(Aufnahme, Aufn_Pos), a=0.08, v=0.16)
                # begin: URCap Program Node
                #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
                #   Type: Schmalz Gripper
                $ 333 "Schmalz: Release"
                set_tool_voltage(24)
                set_tool_digital_out(0, True)
                set_tool_digital_out(1, True)
                sleep(0.5)
                set_tool_digital_out(0, False)
                set_tool_digital_out(1, True)
                sleep(0.05)
                # end: URCap Program Node
                $ 334 "Warten: 0.5"
                sleep(0.5)
                # begin: URCap Program Node
                #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
                #   Type: Schmalz Gripper
                $ 336 "Schmalz: Suction"
                set_tool_voltage(24)
                set_tool_digital_out(0, False)
                set_tool_digital_out(1, False)
                wait_threshold_s = 1.5
                current_time_cnt = 0.0
                while (current_time_cnt<wait_threshold_s):
                  set_tool_digital_out(0, False)
                  set_tool_digital_out(1, False)
                  if (get_tool_digital_in(1)):
                    break
                  end
                  current_time_cnt = current_time_cnt+0.1
                  sleep(0.1)
                end
                # end: URCap Program Node
                $ 337 "set_payload_mass(Greifer_Gewicht+(Artikel_Gewicht*2))"
                set_payload_mass(Greifer_Gewicht+(Artikel_Gewicht*2))
                $ 338 "Drittes Paket aufnehmen"
                $ 339 "Vor_Aufn_Pose≔p[pickup_x/1000,(-1*((karton_dim[1]*1.5/1000)+0.01)),pickup_z_vor/1000,0,0,pickup_rot]"
                global Vor_Aufn_Pose=p[pickup_x/1000,(-1*((karton_dim[1]*1.5/1000)+0.01)),pickup_z_vor/1000,0,0,pickup_rot]
                $ 340 "FahreLinear"
                $ 341 "Vor_Aufn_Pose" "breakAfter"
                movel(pose_trans(Aufnahme, Vor_Aufn_Pose), a=0.08, v=0.16)
                $ 342 "Warten paket_vorne=HI"
                while (get_standard_digital_in(4) == False):
                  sync()
                end
                $ 343 "Aufn_Pos≔p[pickup_x/1000,(-1*(karton_dim[1]*1.5/1000)),((akt_hoe_pick)/1000),0,0,pickup_rot]"
                global Aufn_Pos=p[pickup_x/1000,(-1*(karton_dim[1]*1.5/1000)),((akt_hoe_pick)/1000),0,0,pickup_rot]
                $ 344 "FahreLinear"
                $ 345 "Aufn_Pos" "breakAfter"
                movel(pose_trans(Aufnahme, Aufn_Pos), a=0.08, v=0.16)
                # begin: URCap Program Node
                #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
                #   Type: Schmalz Gripper
                $ 347 "Schmalz: Release"
                set_tool_voltage(24)
                set_tool_digital_out(0, True)
                set_tool_digital_out(1, True)
                sleep(0.5)
                set_tool_digital_out(0, False)
                set_tool_digital_out(1, True)
                sleep(0.05)
                # end: URCap Program Node
                $ 348 "Warten: 0.5"
                sleep(0.5)
                # begin: URCap Program Node
                #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
                #   Type: Schmalz Gripper
                $ 350 "Schmalz: Suction"
                set_tool_voltage(24)
                set_tool_digital_out(0, False)
                set_tool_digital_out(1, False)
                wait_threshold_s = 1.5
                current_time_cnt = 0.0
                while (current_time_cnt<wait_threshold_s):
                  set_tool_digital_out(0, False)
                  set_tool_digital_out(1, False)
                  if (get_tool_digital_in(1)):
                    break
                  end
                  current_time_cnt = current_time_cnt+0.1
                  sleep(0.1)
                end
                # end: URCap Program Node
                $ 351 "set_payload_mass(Greifer_Gewicht+(Artikel_Gewicht*3))"
                set_payload_mass(Greifer_Gewicht+(Artikel_Gewicht*3))
                $ 352 "Freifahren"
                $ 353 "tmp_pose_1≔get_actual_tcp_pose()"
                global tmp_pose_1= get_actual_tcp_pose ()
                $ 354 "tmp_pose_zwi≔pose_trans(tmp_pose_1, p[0,0,0.08,0,0,0])"
                global tmp_pose_zwi=pose_trans(tmp_pose_1, p[0,0,0.08,0,0,0])
                $ 355 "FahreLinear"
                $ 356 "tmp_pose_zwi" "breakAfter"
                movel(tmp_pose_zwi, a=0.06, v=0.16)
                $ 357 "conveyor_start≔ True "
                global conveyor_start=  True  
                $ 358 "Zwischenposition"
                $ 359 "place_rot_ueb≔d2r(liste_paketpos[5]+135)"
                global place_rot_ueb=d2r(liste_paketpos[5]+135)
                $ 360 "tmp_pose_1≔get_actual_tcp_pose()"
                global tmp_pose_1= get_actual_tcp_pose ()
                $ 361 "pose_zwischen≔pose_add(tmp_pose_1, p[-0.360,-0.360,sichere_hoehe,0,0,0])"
                global pose_zwischen= pose_add (tmp_pose_1, p[-0.360,-0.360,sichere_hoehe,0,0,0])
                $ 362 "pose_ueb_pal_2≔p[-0.600,-0.650,sichere_hoehe,0,0,place_rot_ueb]"
                global pose_ueb_pal_2=p[-0.600,-0.650,sichere_hoehe,0,0,place_rot_ueb]
                $ 363 "FahreAchse"
                $ 364 "pose_zwischen" "breakAfter"
                movej(pose_zwischen, a=1.0471975511965976, v=1.5707963267948966, r=0.1)
                $ 365 "pose_ueb_pal_2" "breakAfter"
                movej(pose_ueb_pal_2, a=1.0471975511965976, v=1.5707963267948966)
                $ 366 "gelen_ueb_pal_2≔get_actual_joint_positions()"
                global gelen_ueb_pal_2= get_actual_joint_positions ()
              end
            end
          end
        end
        $ 367 "Paket ablegen"
        $ 368 "place_x≔liste_paketpos[3]*(-1)"
        global place_x=liste_paketpos[3]*(-1)
        $ 369 "place_y≔liste_paketpos[4]*(-1)"
        global place_y=liste_paketpos[4]*(-1)
        $ 370 "place_z≔akt_hoe_place"
        global place_z=akt_hoe_place
        $ 371 "If Akt_Lage≤6"
        if (Akt_Lage <= 6):
          $ 372 "place_z≔akt_hoe_place+3"
          global place_z=akt_hoe_place+3
        end
        $ 373 "If einlaufrichtung≟1"
        if (einlaufrichtung == 1):
          $ 375 "If liste_paketpos[6]≟1"
          if (liste_paketpos[6] == 1):
            $ 376 "place_rot≔d2r(liste_paketpos[5])"
            global place_rot=d2r(liste_paketpos[5])
          else:
            $ 377 "Else" "noBreak"
            $ 378 "place_rot≔d2r(liste_paketpos[5]-90)"
            global place_rot=d2r(liste_paketpos[5]-90)
          end
        else:
          $ 379 "Else" "noBreak"
          $ 380 "If liste_paketpos[6]≟1"
          if (liste_paketpos[6] == 1):
            $ 381 "place_rot≔d2r(liste_paketpos[5])"
            global place_rot=d2r(liste_paketpos[5])
          else:
            $ 382 "Else" "noBreak"
            $ 383 "place_rot≔d2r(liste_paketpos[5]+90)"
            global place_rot=d2r(liste_paketpos[5]+90)
          end
        end
        $ 384 "place_pos≔p[place_x/1000,place_y/1000,(place_z/1000),0,0,place_rot]"
        global place_pos=p[place_x/1000,place_y/1000,(place_z/1000),0,0,place_rot]
        $ 385 "x_vec≔liste_paketpos[7]"
        global x_vec=liste_paketpos[7]
        $ 386 "y_vec≔liste_paketpos[8]"
        global y_vec=liste_paketpos[8]
        $ 387 "place_x_vor≔place_x+(x_vec*50*(-1))"
        global place_x_vor=place_x+(x_vec*50*(-1))
        $ 388 "place_y_vor≔place_y+(y_vec*50*(-1))"
        global place_y_vor=place_y+(y_vec*50*(-1))
        $ 389 "place_z_vor≔place_z+karton_hoehe+30"
        global place_z_vor=place_z+karton_hoehe+30
        $ 390 "place_pos_vor≔p[place_x_vor/1000,place_y_vor/1000,place_z_vor/1000,0,0,place_rot]"
        global place_pos_vor=p[place_x_vor/1000,place_y_vor/1000,place_z_vor/1000,0,0,place_rot]
        $ 391 "Debug Drehwinkel"
        $ 392 "rot_debug_2≔pose_trans(Palette_extend, place_pos_vor)"
        global rot_debug_2= pose_trans (Palette_extend, place_pos_vor)
        $ 393 "rot_debug_trans≔get_inverse_kin(rot_debug_2)"
        global rot_debug_trans= get_inverse_kin (rot_debug_2)
        $ 394 "If rot_debug_trans[5]≥6"
        if (rot_debug_trans[5] >= 6):
          $ 395 "rot_debug_trans[5]=rot_debug_trans[5]-6.28318"
          rot_debug_trans[5]=rot_debug_trans[5]-6.28318
        end
        $ 396 "If rot_debug_trans[5]≤-6"
        if (rot_debug_trans[5] <= -6):
          $ 397 "rot_debug_trans[5]=rot_debug_trans[5]+6.28318"
          rot_debug_trans[5]=rot_debug_trans[5]+6.28318
        end
        $ 401 "movej(rot_debug_trans, a=2, v=3.14)"
        movej(rot_debug_trans, a=2, v=3.14)
        $ 402 "FahreLinear"
        $ 403 "place_pos" "breakAfter"
        movel(pose_trans(Palette_extend, place_pos), a=0.8, v=0.12)
        # begin: URCap Program Node
        #   Source: Schmalz Gripper, 4.0.3, J.Schmalz GmbH
        #   Type: Schmalz Gripper
        $ 405 "Schmalz: Release"
        set_tool_voltage(24)
        set_tool_digital_out(0, True)
        set_tool_digital_out(1, True)
        sleep(0.5)
        set_tool_digital_out(0, False)
        set_tool_digital_out(1, True)
        sleep(0.05)
        # end: URCap Program Node
        $ 406 "set_payload_mass(Greifer_Gewicht)"
        set_payload_mass(Greifer_Gewicht)
        $ 407 "Freifahren Ablage"
        $ 408 "tmp_pose_1≔get_actual_tcp_pose()"
        global tmp_pose_1= get_actual_tcp_pose ()
        $ 409 "tmp_pose_ablage≔pose_trans(tmp_pose_1, p[0,0,0.030,0,0,0])"
        global tmp_pose_ablage= pose_trans (tmp_pose_1, p[0,0,0.030,0,0,0])
        $ 410 "FahreLinear"
        $ 411 "tmp_pose_ablage" "breakAfter"
        movel(tmp_pose_ablage, a=0.08, v=0.06)
        $ 412 "Zurueck zur Aufnahmeposition"
        $ 413 "movej(gelen_ueb_pal_2, a=2, v=3.141)"
        movej(gelen_ueb_pal_2, a=2, v=3.141)
        $ 414 "If Next_Place_near≟ True "
        if (Next_Place_near ==   True  ):
          $ 415 "If liste_nxt_paket[6]≟1"
          if (liste_nxt_paket[6] == 1):
            $ 416 "FahreAchse"
            $ 417 "Gst_Schmalz_nah" "breakAfter"
            movej(Gst_Schmalz_nah_q, a=2.0943951023931953, v=3.141592653589793)
          else:
            $ 419 "Else" "noBreak"
            $ 420 "FahreAchse"
            $ 421 "Gst_Schm_nah_Mu" "breakAfter"
            movej(Gst_Schm_nah_Mu_q, a=2.0943951023931953, v=3.141592653589793)
          end
        else:
          $ 423 "Else" "noBreak"
          $ 424 "If liste_nxt_paket[6]≟1"
          if (liste_nxt_paket[6] == 1):
            $ 425 "FahreAchse"
            $ 426 "Gst_Schmalz_far" "breakAfter"
            movej(Gst_Schmalz_far_q, a=2.0943951023931953, v=3.141592653589793)
          else:
            $ 428 "Else" "noBreak"
            $ 429 "FahreAchse"
            $ 430 "Gst_Schm_far_Mu" "breakAfter"
            movej(Gst_Schm_far_Mu_q, a=2.0943951023931953, v=3.141592653589793)
          end
        end
        $ 432 "Paket_Zaehler≔Paket_Zaehler+1"
        global Paket_Zaehler=Paket_Zaehler+1
      end
      $ 433 "If Zwischenlagen[Akt_Lage-1]≟1"
      if (Zwischenlagen[Akt_Lage-1] == 1):
        $ 434 "signal≔ True "
        global signal=  True  
        $ 435 "Meldung: Zwischenlage einlegen und dann WEITER drücken! Achtung Roboter fährt los!"
        popup("Zwischenlage einlegen und dann WEITER drücken! Achtung Roboter fährt los!", "Meldung", False, False, blocking=True)
        $ 436 "signal≔ False "
        global signal=  False  
      end
      $ 437 "FahreAchse"
      $ 438 "Gst_Schmalz_nah" "breakAfter"
      movej(Gst_Schmalz_nah_q, a=1.3962634015954636, v=1.0471975511965976)
      $ 439 "Akt_Lage≔Akt_Lage+1"
      global Akt_Lage=Akt_Lage+1
    end
    $ 440 "FahreAchse"
    $ 441 "Palettenwechsel" "breakAfter"
    movej(get_inverse_kin(Palettenwechsel_p, qnear=Palettenwechsel_q), a=1.3962634015954636, v=1.0471975511965976)
    # begin: URCap Program Node
    #   Source: LIFTKIT, 1.0.5, SKF Actuation System (Liestal) AG
    #   Type: LIFTKIT
    $ 442 "LIFT: 0mm"
    move_liftkit(0)
    # end: URCap Program Node
    $ 443 "signal≔ True "
    global signal=  True  
    $ 444 "Meldung: Palette wechseln und dann WEITER drücken! Achtung Roboter fährt los!"
    popup("Palette wechseln und dann WEITER drücken! Achtung Roboter fährt los!", "Meldung", False, False, blocking=True)
    $ 445 "signal≔ False "
    global signal=  False  
    $ 446 "Akt_Lage≔1"
    global Akt_Lage=1
    $ 447 "lift_hoehe≔0"
    global lift_hoehe=0
    $ 448 "Akt_Lifthoehe≔0"
    global Akt_Lifthoehe=0
  end
end
